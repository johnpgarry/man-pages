.\" (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Sat Jul 24 19:27:50 1993 by Rik Faith (faith@cs.unc.edu)
.TH GETOPT 3  "April 25, 1993" "GNU" "Linux Programmer's Manual"
.SH NAME
getopt \- Read command line options
.SH SYNOPSIS
.nf
.B #include <unistd.h>
.sp
.BI "int getopt(int " argc ", char * const " argv[] ","
.BI "           const char *" optstring ");"
.sp
.BI "extern char *" optarg ;
.BI "extern int " optind ", " opterr ", " optopt ;
.sp
.B #include <getopt.h>
.sp
.BI "int getopt_long(int " argc ", char * const " argv[] ",
.BI "                const char *" shortopts ,
.BI "                const struct option *" longopts ", int " longind ");"
.fi
.SH DESCRIPTION
The
.B getopt()
function parses the command line arguments.  Its arguments
.I argc
and
.I argv
are the argument count and array as passed to the
.B main()
function on program invocation.
.I optstring
is a list of available option characters.  If such a character is
followed by a colon, the option takes an argument, which is placed in
.IR optarg .
.PP
The external variable
.I optind
is the index of the next array element of
.I argv[]
to be processed; it communicates from one call of
.B getopt()
to the next which element to process.
.PP
The
.B getopt_long()
function works like
.B getopt()
except that it also accepts long options, started out by two dashes.
If these take values, it is either in the form
.B --arg=value
or
.BR "--arg value" .
It takes the additional arguments
.I longopts
which is a pointer to the first element of an array of
.B struct option
declared in
.B <getopt.h>
as
.nf
.sp
.in 10
struct option {
.in 14
const char *name;
int has_arg;
int *flag;
int val;
.in 10
};
.sp
.fi
The meaning of the different fields are:
.TP
.I name
is the name of the long option.
.TP
.I has_arg
is a boolean value which should be set to nonzero if the long option
takes a value.
.TP
.I flag
determines the return value if
.B getopt_long()
returns a value for a long option; if it is non-zero, zero is
returned as a function value, otherwise
.IR val .
.TP
.I val
determines the value to return if
.I flag
is zero.
.PP
The last element of the array has to be filled with zeroes.
.PP
The
.I option_index
points to the index of the long option relative to
.IR longopts .
.SH "RETURN VALUE"
The
.B getopt()
function returns the option character if the option was found
successfully, ':' if there was a missing parameter for one of the
options, '?' for an unknown option character and \-1 for the end of the
option list.
.SH "EXAMPLE"
The following example program, from the source code, illustrates the
use of
.BR getopt_long()
with most of its features.
.nf
.sp
#include <stdio.h>

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
	{"add", 1, 0, 0},
	{"append", 0, 0, 0},
	{"delete", 1, 0, 0},
	{"verbose", 0, 0, 0},
	{"create", 1, 0, 'c'},
	{"file", 1, 0, 0},
	{0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:012",
		       long_options, &option_index);
      if (c == -1)
	break;

      switch (c)
	{
	case 0:
	  printf ("option %s", long_options[option_index].name);
	  if (optarg)
	    printf (" with arg %s", optarg);
	  printf ("\n");
	  break;

	case '0':
	case '1':
	case '2':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case 'd':
	  printf ("option d with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}
.fi
.SH "BUGS"
This manpage is confusing.
.SH "CONFORMS TO"
.TP
.BR getopt() " :"
POSIX.1
