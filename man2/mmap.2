.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 1996 Andries Brouwer (aeb@cwi.nl)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified Fri Jan 31 16:38:25 1997 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Sat Mar 25 08:11:16 2000 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\"
.TH MMAP 2 2000-03-25 "Linux 2.3.51" "Linux Programmer's Manual"
.SH NAME
mmap, munmap \- map or unmap files or devices into memory
.SH SYNOPSIS
.B #include <unistd.h>
.br
.B #include <sys/mman.h>
.sp
.B #ifdef _POSIX_MAPPED_FILES
.sp
.BI "void * mmap(void *" start ", size_t " length ", int " prot
.BI ", int " flags ", int " fd ", off_t " offset );
.sp
.BI "int munmap(void *" start ", size_t " length );
.sp
.B #endif
.SH DESCRIPTION
The
.B mmap
function asks to map
.I length
bytes starting at offset
.I offset
from the file (or other object) specified by the file descriptor
.I fd
into memory, preferably at address
.IR start .
This latter address is a hint only, and is usually specified as 0.
The actual place where the object is mapped is returned by
.BR mmap .
The
.I prot
argument describes the desired memory protection (and must not
conflict with the open mode of the file). It has bits
.TP 1.1i
.B PROT_EXEC
Pages may be executed.
.TP
.B PROT_READ
Pages may be read.
.TP
.B PROT_WRITE
Pages may be written.
.TP
.B PROT_NONE
Pages may not be accessed.
.LP
The
.I flags
parameter specifies the type of the mapped object, mapping options and
whether modifications made to the mapped copy of the page are private to
the process or are to be shared with other references.  It has bits
.TP 1.1i
.B MAP_FIXED
Do not select a different address than the one specified.
If the specified address cannot be used,
.B mmap
will fail.  If MAP_FIXED is specified,
.I start
must be a multiple of the pagesize.  Use of this option is discouraged.
.TP
.B MAP_SHARED
Share this mapping with all other processes that map this object.
Storing to the region is equivalent to writing to the file.
The file may not actually be updated until
.BR msync (2)
or
.BR munmap (2)
are called.
.TP
.B MAP_PRIVATE
Create a private copy-on-write mapping.
Stores to the region do not affect the original file.
.LP
You must specify exactly one of MAP_SHARED and MAP_PRIVATE.
.LP
The above three flags are described in POSIX.1b (formerly POSIX.4).
Linux also knows about MAP_DENYWRITE, MAP_EXECUTABLE,
MAP_NORESERVE, MAP_LOCKED, MAP_GROWSDOWN and MAP_ANON(YMOUS).
.LP
.I offset
should ordinarily be a multiple of the page size returned by
.BR getpagesize (2).
.LP
Memory mapped by
.B mmap
is preserved across
.BR fork (2),
with the same attributes.

The
.B munmap
system call deletes the mappings for the specified address range, and
causes further references to addresses within the range to generate
invalid memory references.  The region is also automatically unmapped
when the process is terminated.  On the other hand, closing the file
descriptor does not unmap the region.

.SH "RETURN VALUE"
On success,
.B mmap
returns a pointer to the mapped area.
On error, MAP_FAILED (\-1) is returned, and
.I errno
is set appropriately.
On success,
.B munmap
returns 0, on failure \-1, and
.I errno
is set (probably to EINVAL).
.SH ERRORS
.TP
.B EBADF
.I fd
is not a valid file descriptor (and MAP_ANONYMOUS was not set).
.TP
.B EACCES
MAP_PRIVATE was requested, but
.I fd
is not open for reading.  Or MAP_SHARED was requested and PROT_WRITE is set,
but
.I fd
is not open in read/write (O_RDWR) mode.
.TP
.B EINVAL
We don't like
.I start
or
.I length
or
.IR offset .
(E.g., they are too large, or not aligned on a PAGESIZE boundary.)
.TP
.B ETXTBSY
MAP_DENYWRITE was set but the object specified by
.I fd
is open for writing.
.TP
.B EAGAIN
The file has been locked, or too much memory has been locked.
.TP
.B ENOMEM
No memory is available.
.LP
Use of a mapped region can result in these signals:
.TP
.B SIGSEGV
Attempted write into a region specified to mmap as read-only.
.TP
.B SIGBUS
Attempted access to a portion of the buffer that does not correspond
to the file (for example, beyond the end of the file, including the
case where another process has truncated the file).
.SH "CONFORMING TO"
SVr4, POSIX.1b (formerly POSIX.4), 4.4BSD.  Svr4 documents additional
error codes ENXIO and ENODEV.
.SH "SEE ALSO"
.BR getpagesize (2),
.BR msync (2),
.BR shm_open (2),
B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391.
